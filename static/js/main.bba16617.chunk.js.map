{"version":3,"sources":["components/templates/Template.tsx","components/Segmentation.tsx","components/Settings.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Template","children","title","console","log","BottomNavigation","showLabels","value","BottomNavigationAction","component","Link","to","label","icon","Buttons","isCameraEnable","setCameraEnable","isCaptured","setCaptured","setShutter","shutter","setDetected","isDetected","facingMode","setFacingMode","isBackgroundEnable","setBackgroundEnable","processing","style","display","justifyContent","alignItems","IconButton","disabled","color","onClick","Switch","defaultChecked","onChange","Canvas","webcamRef","width","height","setProcessing","setCapturedTime","capturedTime","background","peopleCount","setPeopleCount","cameraSize","setCameraSize","screenshotRef","useRef","drawCanvasRef","detectRef","useState","model","setModel","predictions","setPredictions","Image","screenshot","setScreenshot","canvasRef","GetCameraSize","a","setTimeout","current","webcamCurrent","video","readyState","imgSrc","getScreenshot","img","src","onload","naturalWidth","naturalHeight","GetScreenshot","date","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","Detect","segmentMultiPerson","internalResolution","preds","length","DrawCanvas","canvas","foregroundColor","r","g","b","backgroundColor","mask","bodyPix","context","getContext","drawImage","LoadModel","architecture","outputStride","quantBytes","bodypix","useEffect","Object","keys","audio","ref","videoConstraints","margin","textAlign","zIndex","visibility","CircularProgress","Segmentation","setBackgroudEnable","getWindowDimensions","window","innerWidth","innerHeight","windowDimensions","setWindowDimensions","onResize","addEventListener","removeEventListener","UseWindowDimensions","setBackground","Settings","App","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","basename","process","document","getElementById"],"mappings":"icAYaA,EAAoC,SAAC,GAG3C,IAFHC,EAEE,EAFFA,SACAC,EACE,EADFA,MAIA,OAFAC,QAAQC,IAAIF,GAGR,qCACI,8BACKD,IAEL,eAACI,EAAA,EAAD,CACIC,YAAU,EACVC,MAAOL,EAFX,UAII,cAACM,EAAA,EAAD,CACIC,UAAWC,IACXC,GAAG,qBACHJ,MAAM,eACNK,MAAM,QACNC,KAAM,cAAC,IAAD,MAEV,cAACL,EAAA,EAAD,CACIC,UAAWC,IACXC,GAAG,iBACHJ,MAAM,WACNK,MAAM,WACNC,KAAM,cAAC,IAAD,aCIpBC,EAAkC,SAAC,GAcnC,EAbFC,eAaE,EAZFC,gBAYG,IAXHC,EAWE,EAXFA,WACAC,EAUE,EAVFA,YAEAC,GAQE,EATFC,QASE,EARFD,YAEAE,GAME,EAPFC,WAOE,EANFD,aACAE,EAKE,EALFA,WACAC,EAIE,EAJFA,cACAC,EAGE,EAHFA,mBACAC,EAEE,EAFFA,oBACAC,EACE,EADFA,WAEA,OACI,sBACIC,MAAO,CACHC,QAAS,OACTC,eAAgB,eAChBC,WAAY,UAJpB,UAQI,eAACC,EAAA,EAAD,CAAYC,SAAUN,EAAtB,UACKV,GACG,cAAC,IAAD,CAAeiB,MAAOP,EAAa,WAAa,UAAWQ,QAAS,kBAAMhB,GAAW,MAExFF,GACG,cAAC,IAAD,CACIiB,MAAOP,EAAa,WAAa,UACjCQ,QAAS,WACLjB,GAAY,GACZG,GAAY,SAO5B,eAACW,EAAA,EAAD,CAAYC,SAAUhB,GAAcU,EAApC,UACMV,GACE,cAAC,IAAD,CAAmBiB,MAAM,aAE5BjB,GACG,qCACoB,SAAfM,GACG,cAAC,IAAD,CAAmBW,MAAOP,EAAa,WAAa,UAAWQ,QAAS,kBAAMX,EAAc,kBAEhF,gBAAfD,GACG,cAAC,IAAD,CAAmBW,MAAOP,EAAa,WAAa,UAAWQ,QAAS,kBAAMX,EAAc,iBAO5G,cAACY,EAAA,EAAD,CAAQC,gBAAc,EAACH,MAAM,UAAUD,UAAWhB,EAAYqB,SAAU,kBAAMZ,GAAqBD,MAGnG,cAACO,EAAA,EAAD,CAAYC,UAAU,EAAtB,SACI,cAAC,IAAD,CAAiBC,MAAM,mBA6BjCK,EAAgC,SAAC,GAqBhC,IApBHC,EAoBE,EApBFA,UACAjB,EAmBE,EAnBFA,WACAkB,EAkBE,EAlBFA,MACAC,EAiBE,EAjBFA,OACAzB,EAgBE,EAhBFA,WACAC,EAeE,EAfFA,YACAO,EAcE,EAdFA,mBACAL,EAaE,EAbFA,QACAD,EAYE,EAZFA,WACAG,EAWE,EAXFA,WACAD,EAUE,EAVFA,YACAM,EASE,EATFA,WACAgB,EAQE,EARFA,cAEAC,GAME,EAPFC,aAOE,EANFD,iBAGAE,GAGE,EALFC,YAKE,EAJFC,eAIE,EAHFF,YACAG,EAEE,EAFFA,WACAC,EACE,EADFA,cAEMC,EAAgBC,kBAAO,GACvBC,EAAgBD,kBAAO,GACvBE,EAAYF,kBAAO,GACzB,EAA0BG,mBAAc,MAAxC,mBAAOC,EAAP,KAAcC,EAAd,KACA,EAAsCF,mBAAc,MAApD,mBAAOG,EAAP,KAAoBC,EAApB,KACA,EAAoCJ,mBAA2B,IAAIK,OAAnE,mBAAOC,EAAP,KAAmBC,EAAnB,KACMC,EAAYX,iBAA0B,MAEtCY,EAAa,uCAAG,sBAAAC,EAAA,sDAClB9D,QAAQC,IAAI,8BACZ8D,YAAW,WACP,GAAI1B,EAAU2B,QAAS,CACnB,IAAMC,EAAgB5B,EAAU2B,QAGhC,GAFAhE,QAAQC,IAAI,iBACZD,QAAQC,IAAIgE,EAAcC,MAAMC,YACO,IAAnCF,EAAcC,MAAMC,WAAkB,CAAC,IAAD,EAChCC,EAAM,UAAG/B,EAAU2B,eAAb,aAAG,EAAmBK,gBAC9BC,EAAM,IAAIb,MACda,EAAIC,IAAMH,EACVE,EAAIE,OAAS,WACTxE,QAAQC,IAAI,kBAAkBqE,EAAIG,cAClCzE,QAAQC,IAAI,mBAAmBqE,EAAII,eACnC3B,EAAc,CAACuB,EAAIG,aAAcH,EAAII,gBACrC1E,QAAQC,IAAI,eAAe6C,GAC3B9C,QAAQC,IAAI,iCAIzB,KApBe,2CAAH,qDAsBb0E,EAAa,uCAAG,sBAAAb,EAAA,sDAClB9D,QAAQC,IAAI,qBACZ8D,YAAW,WACP,GAAI1B,EAAU2B,QAAS,CACnB,IAAMC,EAAgB5B,EAAU2B,QAEhC,GADAhE,QAAQC,IAAI,iBAC2B,IAAnCgE,EAAcC,MAAMC,WAAkB,CAAC,IAAD,EAChCC,EAAM,UAAG/B,EAAU2B,eAAb,aAAG,EAAmBK,gBAC9BC,EAAM,IAAIb,MACda,EAAIC,IAAMH,EACV,IAAMQ,EAAO,IAAIC,KACjBpC,EAAgBmC,EAAKE,cAAc,KAAKF,EAAKG,WAAW,GAAG,IAAIH,EAAKI,UAAU,IAAIJ,EAAKK,WAAW,IAAIL,EAAKM,aAAa,IAAIN,EAAKO,cACjIb,EAAIE,OAAS,WACTxE,QAAQC,IAAI,mBACZ0D,EAAcW,GACdtE,QAAQC,IAAI,qBAAqBqE,EAAIG,cACrCzE,QAAQC,IAAI,sBAAsBqE,EAAII,eACtC1D,GAAW,GACXD,GAAY,QAIzB,KAtBe,2CAAH,qDAwBbqE,EAAM,uCAAG,4BAAAtB,EAAA,yDACXN,EAAe,OACX1C,EAFO,wBAGPd,QAAQC,IAAI,iBACZuC,GAAc,GAQa,OAZpB,SAcaa,EAAMgC,mBAAmB3B,EAAY,CACrD4B,mBAHuB,SAZpB,OAcDC,EAdC,OAiBPvF,QAAQC,IAAI,eACRsF,EAAMC,QACNxF,QAAQC,IAAIsF,GACZ/B,EAAe+B,IAEfvF,QAAQC,IAAI,iBAEhBuC,GAAc,GACdtB,GAAY,GAzBL,4CAAH,qDA4BNuE,EAAU,uCAAG,oCAAA3B,EAAA,sDACXhD,GACI8C,EAAUI,UACVhE,QAAQC,IAAI,iBACZD,QAAQC,IAAI2D,EAAUI,QAAQ1B,OAC9BtC,QAAQC,IAAIyD,EAAWe,cACvBb,EAAUI,QAAQ1B,MAAQoB,EAAWe,aACrCb,EAAUI,QAAQzB,OAASmB,EAAWgB,cAEtB,IACO,EACA,EACjBgB,EAAS9B,EAAUI,QAErBT,GACMoC,EAAkB,CAACC,EAAG,IAAKC,EAAG,EAAGC,EAAG,EAAGhC,EAAG,KAC1CiC,EAAkB,CAACH,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGhC,EAAG,GACxCkC,EAAOC,IACT1C,EACAoC,EACAI,GAGAzE,EACA2E,IACIP,EACAhC,EACAsC,EAlBI,GAEO,EADA,OAuBfC,IACIP,EACA/C,EACAqD,EA3BI,GAEO,EADA,SAiCbE,EAAUtC,EAAUI,QAAQmC,WAAW,SAErC7E,EACA4E,EAAQE,UAAU1C,EAAY,EAAG,GAEjCwC,EAAQE,UAAUzD,EAAY,EAAG,IAM7C3C,QAAQC,IAAI,WAtDL,2CAAH,qDA0DVoG,EAAS,uCAAG,4BAAAvC,EAAA,6DACd9D,QAAQC,IAAI,wBACZuC,GAAc,GAMO,cACA,GACF,EAVL,SAWQyD,IAAa,CAChCK,aAJkB,cAKlBC,aAJkB,GAKlBC,WAJgB,IAVL,OAWRC,EAXQ,OAgBdnD,EAASmD,GACTjE,GAAc,GACdxC,QAAQC,IAAI,iBAlBE,4CAAH,qDA0Df,OArCAyG,qBAAU,WACDlF,GACsC,IAAnCmF,OAAOC,KAAK9D,GAAY0C,QACxB3B,MAGT,CAACrC,IAEJkF,qBAAU,WACNL,MACD,IAEHK,qBAAU,WACF1D,EAAcgB,QACdhB,EAAcgB,SAAU,EAG5BW,MACD,CAAC1D,IAEJyF,qBAAU,WACFxD,EAAcc,QACdd,EAAcc,SAAU,EAG5BoB,MACD,CAACtE,IAEJ4F,qBAAU,WACFvD,EAAUa,QACVb,EAAUa,SAAU,EAGxByB,MACD,CAACtE,EAAYG,IAEhBtB,QAAQC,IAAI,UAAWgB,EAAS,aAAcO,EAAY,aAAcV,EAAY,YAAcA,IAAeU,GAE7G,sBACIC,MAAO,CACHa,MAAOA,EACPC,OAAe,GAAPA,EACRb,QAAS,OACTC,eAAgB,SAChBC,WAAY,UANpB,WASOX,IAAYH,IAAeU,GAAiD,IAAnCmF,OAAOC,KAAK9D,GAAY0C,QAChE,cAAC,IAAD,CACIqB,OAAO,EACPC,IAAKzE,EACL0E,iBAAkB,CACd3F,WAAYA,GAEhBK,MAAO,CACHuF,OAAQ,OACRC,UAAW,SACXC,OAAQ,EACRC,WAAY,aAIrBlG,IAAYH,IAAeU,GAAiD,IAAnCmF,OAAOC,KAAK9D,GAAY0C,QAChE,cAAC,IAAD,CACIqB,OAAO,EACPC,IAAKzE,EACL0E,iBAAkB,CACd3F,WAAYA,GAEhBK,MAAO,CACHuF,OAAQ,OACRC,UAAW,SACXC,OAAQ,EACR5E,MAAO,OACPC,OAAQ,UAIlBtB,IAAYH,IAAeU,GAAiD,IAAnCmF,OAAOC,KAAK9D,GAAY0C,QAC/D,cAAC,IAAD,CACIqB,OAAO,EACPC,IAAKzE,EACL0E,iBAAkB,CACd3F,WAAYA,GAEhBK,MAAO,CACHuF,OAAQ,OACRC,UAAW,SACXC,OAAQ,EACR5E,MAAOQ,EAAW,GAClBP,OAAQO,EAAW,GACnBqE,WAAY,YAIvB3F,GACG,cAAC4F,EAAA,EAAD,IAGFtG,IAAeU,GACb,mCACI,wBACIsF,IAAKlD,EACLnC,MAAO,CACHuF,OAAQ,OACR1E,MAAO,OACPC,OAAQ,OACR2E,OAAQ,YAevBG,EAA4C,SAAC,GAInD,IAHH1E,EAGE,EAHFA,WACAG,EAEE,EAFFA,WACAC,EACE,EADFA,cAEA,EAA0CK,oBAAkB,GAA5D,mBAAOxC,EAAP,KAAuBC,EAAvB,KACA,EAAkCuC,oBAAkB,GAApD,mBAAOtC,EAAP,KAAmBC,EAAnB,KACA,EAA8BqC,oBAAkB,GAAhD,mBAAOnC,EAAP,KAAgBD,EAAhB,KACA,EAAkCoC,oBAAkB,GAApD,mBAAOjC,EAAP,KAAmBD,EAAnB,KACA,EAAiDkC,oBAAkB,GAAnE,mBAAO9B,EAAP,KAA2BgG,EAA3B,KACA,EAAoClE,mBAAiB,QAArD,mBAAOhC,EAAP,KAAmBC,EAAnB,KACA,EAAoC+B,oBAAkB,GAAtD,mBAAO5B,EAAP,KAAmBgB,EAAnB,KACA,EAAwCY,mBAAiB,IAAzD,mBAAOV,EAAP,KAAqBD,EAArB,KACA,EAAsCW,mBAAiB,GAAvD,mBAAOR,EAAP,KAAoBC,EAApB,KACA,EAxbwB,WACxB,IAAM0E,EAAsB,WACxB,MAAmDC,OACnD,MAAO,CAAElF,MADT,EAAQmF,WACQlF,OADhB,EAA2BmF,cAG/B,EAAgDtE,mBAASmE,KAAzD,mBAAOI,EAAP,KAAyBC,EAAzB,KAQA,OAPAlB,qBAAU,WACN,IAAMmB,EAAW,WACbD,EAAoBL,MAGxB,OADAC,OAAOM,iBAAiB,SAAUD,GAC3B,kBAAML,OAAOO,oBAAoB,SAAUF,MACnD,IACIF,EA2amBK,GAAlB1F,EAAR,EAAQA,MAAOC,EAAf,EAAeA,OACTF,EAAYY,iBAAe,MACjC,OACI,eAAC,EAAD,CAAUlD,MAAM,eAAhB,UACI,cAAC,EAAD,CACIa,eAAgBA,EAChBC,gBAAiBA,EACjBC,WAAYA,EACZC,YAAaA,EACbE,QAASA,EACTD,WAAYA,EACZG,WAAYA,EACZD,YAAaA,EACbE,WAAYA,EACZC,cAAeA,EACfC,mBAAoBA,EACpBC,oBAAqB+F,EACrB9F,WAAYA,IAEhB,cAAC,EAAD,CACIa,UAAWA,EACXjB,WAAYA,EACZkB,MAAOA,EACPC,OAAQA,EACRzB,WAAYA,EACZC,YAAaA,EACbO,mBAAoBA,EACpBL,QAASA,EACTD,WAAYA,EACZG,WAAYA,EACZD,YAAaA,EACbM,WAAYA,EACZgB,cAAeA,EACfE,aAAcA,EACdD,gBAAiBA,EACjBG,YAAaA,EACbC,eAAgBA,EAChBF,WAAYA,EACZG,WAAYA,EACZC,cAAeA,QCxczBpC,EAAkC,SAAC,GAOlC,IANHG,EAME,EANFA,WACAC,EAKE,EALFA,YACAK,EAIE,EAJFA,WACAC,EAGE,EAHFA,cAEAL,GACE,EAFFC,QAEE,EADFD,YAEA,OACI,sBACIS,MAAO,CACHC,QAAS,OACTC,eAAgB,eAChBC,WAAY,UAJpB,UAOI,cAACC,EAAA,EAAD,UACI,cAAC,IAAD,CACIE,MAAM,UACNC,QAAS,WACAlB,EAGDC,GAAY,GAFZC,GAAW,QAO3B,cAACa,EAAA,EAAD,CAAYC,SAAUhB,EAAtB,SACI,cAAC,IAAD,CACIiB,MAAOjB,EAAa,WAAa,UACjCkB,QAAS,WACc,SAAfZ,EACAC,EAAc,eACQ,gBAAfD,GACPC,EAAc,iBAsBpCe,EAAgC,SAAC,GAWhC,IAVHC,EAUE,EAVFA,UACAvB,EASE,EATFA,WACAC,EAQE,EARFA,YACAK,EAOE,EAPFA,WACAH,EAME,EANFA,QACAD,EAKE,EALFA,WACA2B,EAIE,EAJFA,WACAsF,EAGE,EAHFA,cACA3F,EAEE,EAFFA,MACAC,EACE,EADFA,OAEMqB,EAAYX,iBAA0B,MACtC0B,EAAa,uCAAG,kCAAAb,EAAA,sDACdzB,EAAU2B,UACJC,EAAgB5B,EAAU2B,QAChChE,QAAQC,IAAI,iBAC2B,IAAnCgE,EAAcC,MAAMC,aACdC,EADgC,UACvB/B,EAAU2B,eADa,aACvB,EAAmBK,iBAC9BC,EAAM,IAAIb,OACVc,IAAMH,EACVE,EAAIE,OAAS,WACTyD,EAAc3D,GACdtD,GAAW,GACXD,GAAY,MAXN,2CAAH,qDAgBb0E,EAAU,uCAAG,4BAAA3B,EAAA,sDACXhD,GACI8C,EAAUI,UACVJ,EAAUI,QAAQ1B,MAAQK,EAAW8B,aACrCb,EAAUI,QAAQzB,OAASI,EAAW+B,cAE/B,QADDwB,EAAUtC,EAAUI,QAAQmC,WAAW,aACtC,IAAPD,KAASE,UAAUzD,EAAY,EAAG,IAN3B,2CAAH,qDAmBhB,OARA+D,qBAAU,WACN/B,MACD,CAAC1D,IAEJyF,qBAAU,WACNjB,MACD,CAAC3E,IAGA,sBACIW,MAAO,CACHa,MAAOA,EACPC,OAAe,GAAPA,EACRb,QAAS,OACTC,eAAgB,SAChBC,WAAY,UANpB,WASMd,GACE,cAAC,IAAD,CACI+F,OAAO,EACPC,IAAKzE,EACL0E,iBAAkB,CACd3F,WAAYA,GAEhBK,MAAO,CACHuF,OAAQ,OACRC,UAAW,SACXC,OAAQ,EACR5E,MAAO,OACPC,OAAQ,UAInBzB,GACG,mCACI,wBACIgG,IAAKlD,EACLnC,MAAO,CACHuF,OAAQ,OACR1E,MAAO,OACPC,OAAQ,OACR2E,OAAQ,YAevBgB,EAAoC,SAAC,GAI3C,IAHHvF,EAGE,EAHFA,WACAsF,EAEE,EAFFA,cAGA,GADE,EADFnF,WAvLwB,WACxB,IAAMyE,EAAsB,WACxB,MAAmDC,OACnD,MAAO,CAAElF,MADT,EAAQmF,WACQlF,OADhB,EAA2BmF,cAG/B,EAAgDtE,mBAASmE,KAAzD,mBAAOI,EAAP,KAAyBC,EAAzB,KAQA,OAPAlB,qBAAU,WACN,IAAMmB,EAAW,WACbD,EAAoBL,MAGxB,OADAC,OAAOM,iBAAiB,SAAUD,GAC3B,kBAAML,OAAOO,oBAAoB,SAAUF,MACnD,IACIF,EA4KmBK,IAAlB1F,EAAR,EAAQA,MAAOC,EAAf,EAAeA,OACf,EAAkCa,oBAAkB,GAApD,mBAAOtC,EAAP,KAAmBC,EAAnB,KACA,EAAoCqC,mBAAiB,QAArD,mBAAOhC,EAAP,KAAmBC,EAAnB,KACA,EAA8B+B,oBAAkB,GAAhD,mBAAOnC,EAAP,KAAgBD,EAAhB,KACMqB,EAAYY,iBAAe,MACjC,OACI,eAAC,EAAD,CAAUlD,MAAM,WAAhB,UACI,cAAC,EAAD,CACIe,WAAYA,EACZC,YAAaA,EACbK,WAAYA,EACZC,cAAeA,EACfJ,QAASA,EACTD,WAAYA,IAEhB,cAAC,EAAD,CACIqB,UAAWA,EACXvB,WAAYA,EACZC,YAAaA,EACbK,WAAYA,EACZH,QAASA,EACTD,WAAYA,EACZ2B,WAAYA,EACZsF,cAAeA,EACf3F,MAAOA,EACPC,OAAQA,QCzKT4F,EAlCO,WACpB,MAAoC/E,mBAA2B,IAAIK,OAAnE,mBAAOd,EAAP,KAAmBsF,EAAnB,KACA,EAAoC7E,mBAAmB,IAAvD,mBAAON,EAAP,KAAmBC,EAAnB,KACA,OACE,cAAC,IAAD,UACE,eAAC,IAAD,WASE,cAAC,IAAD,CAAOqF,KAAK,qBAAZ,SACE,cAAC,EAAD,CACEzF,WAAYA,EACZG,WAAYA,EACZC,cAAeA,MAGnB,cAAC,IAAD,CAAOqF,KAAK,iBAAZ,SACE,cAAC,EAAD,CACEzF,WAAYA,EACZsF,cAAeA,EACfnF,WAAYA,YC3BTuF,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,IAAD,CAAQC,SAAUC,QAAlB,SACE,cAAC,EAAD,QAGJC,SAASC,eAAe,SAM1Bf,M","file":"static/js/main.bba16617.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport BottomNavigation from '@material-ui/core/BottomNavigation';\nimport BottomNavigationAction from '@material-ui/core/BottomNavigationAction';\nimport CameraAltIcon from '@material-ui/icons/CameraAlt';\nimport SettingsIcon from '@material-ui/icons/Settings';\n\ninterface TemplateProps {\n    children: React.ReactNode\n    title: string\n}\n\nexport const Template: React.FC<TemplateProps> = ({\n    children,\n    title\n}) => {\n    console.log(title);\n\n    return (\n        <>\n            <div>\n                {children}\n            </div>\n            <BottomNavigation\n                showLabels\n                value={title}\n            >\n                <BottomNavigationAction\n                    component={Link}\n                    to='/tfjs/segmentation'\n                    value='segmentation'\n                    label='photo'\n                    icon={<CameraAltIcon/>}\n                />\n                <BottomNavigationAction\n                    component={Link}\n                    to='/tfjs/settings'\n                    value='settings'\n                    label='settings'\n                    icon={<SettingsIcon/>}\n                />\n            </BottomNavigation>\n        </>\n    );\n}","import React, { useState, useEffect, useRef } from 'react';\nimport Switch from '@material-ui/core/Switch';\nimport { IconButton } from '@material-ui/core';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nimport CameraAltIcon from '@material-ui/icons/CameraAlt';\nimport CloudUploadIcon from '@material-ui/icons/CloudUpload';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport Webcam from 'react-webcam';\nimport '@tensorflow/tfjs-backend-cpu';\nimport * as bodyPix from '@tensorflow-models/body-pix';\nimport { Template } from './templates/Template';\n\nconst UseWindowDimensions = () => {\n    const getWindowDimensions = () => {\n        const { innerWidth: width, innerHeight: height } = window;\n        return { width, height }\n    }\n    const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n    useEffect(() => {\n        const onResize = () => {\n            setWindowDimensions(getWindowDimensions());\n        }\n        window.addEventListener('resize', onResize);\n        return () => window.removeEventListener('resize', onResize);\n    }, []);\n    return windowDimensions;\n}\n\ninterface ButtonsProps {\n    isCameraEnable: boolean\n    setCameraEnable: Function\n    isCaptured: boolean\n    setCaptured: Function\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    facingMode: string\n    setFacingMode: Function\n    isBackgroundEnable: boolean\n    setBackgroundEnable: Function\n    processing: boolean\n}\nconst Buttons: React.FC<ButtonsProps> = ({\n    isCameraEnable,\n    setCameraEnable,\n    isCaptured,\n    setCaptured,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    facingMode,\n    setFacingMode,\n    isBackgroundEnable,\n    setBackgroundEnable,\n    processing\n}) => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'space-around',\n                alignItems: 'center'\n            }}\n        >\n            {/* camera start or capture button */}\n            <IconButton disabled={processing}>\n                {isCaptured ||\n                    <CameraAltIcon color={processing ? 'disabled' : 'primary'} onClick={() => setShutter(true)}/>\n                }\n                {isCaptured &&\n                    <CameraAltIcon \n                        color={processing ? 'disabled' : 'primary'} \n                        onClick={() => {\n                            setCaptured(false)\n                            setDetected(false)\n                        }}\n                    />\n                }\n            </IconButton>\n\n            {/* select camera */}\n            <IconButton disabled={isCaptured || processing}>\n                {(isCaptured) && \n                    <FlipCameraIosIcon color='disabled'/>\n                }\n                {isCaptured ||\n                    <>\n                        {facingMode === 'user' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('environment')}/>\n                        }\n                        {facingMode === 'environment' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('user')}/>\n                        }\n                    </>\n                }\n            </IconButton>\n\n            {/* background */}\n            <Switch defaultChecked color='primary' disabled={!isCaptured} onChange={() => setBackgroundEnable(!isBackgroundEnable)} />\n\n            {/* upload */}\n            <IconButton disabled={true}>\n                <CloudUploadIcon color='disabled'/>\n            </IconButton>\n        </div>\n    );\n}\n\ninterface CanvasProps {\n    webcamRef: any\n    facingMode: string\n    width: number\n    height: number\n    isCaptured: boolean\n    setCaptured: Function\n    isBackgroundEnable: boolean\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    processing: boolean\n    setProcessing: Function\n    capturedTime: string\n    setCapturedTime: Function\n    peopleCount: number\n    setPeopleCount: Function\n    background: HTMLImageElement\n    cameraSize: number[]\n    setCameraSize: Function\n}\n\nconst Canvas: React.FC<CanvasProps> = ({\n    webcamRef,\n    facingMode,\n    width,\n    height,\n    isCaptured,\n    setCaptured,\n    isBackgroundEnable,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    processing,\n    setProcessing,\n    capturedTime,\n    setCapturedTime,\n    peopleCount,\n    setPeopleCount,\n    background,\n    cameraSize,\n    setCameraSize\n}) => {\n    const screenshotRef = useRef(true);\n    const drawCanvasRef = useRef(true);\n    const detectRef = useRef(true);\n    const [model, setModel] = useState<any>(null);\n    const [predictions, setPredictions] = useState<any>(null);\n    const [screenshot, setScreenshot] = useState<HTMLImageElement>(new Image);\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const GetCameraSize = async () => {\n        console.log('start getting camera size.');\n        setTimeout(() => {\n            if (webcamRef.current) {\n                const webcamCurrent = webcamRef.current as any;\n                console.log('webcam ready.');\n                console.log(webcamCurrent.video.readyState);\n                if (webcamCurrent.video.readyState === 4) {\n                    const imgSrc = webcamRef.current?.getScreenshot();\n                    let img = new Image;\n                    img.src = imgSrc;\n                    img.onload = () => {\n                        console.log('natural width: '+img.naturalWidth);\n                        console.log('natural height: '+img.naturalHeight);\n                        setCameraSize([img.naturalWidth, img.naturalHeight]);\n                        console.log('cameraSize: '+cameraSize);\n                        console.log('end getting camera size.');\n                    }\n                }\n            }\n        }, 2000);\n    }\n    const GetScreenshot = async () => {\n        console.log('start screenshot.');\n        setTimeout(() => {\n            if (webcamRef.current) {\n                const webcamCurrent = webcamRef.current as any;\n                console.log('webcam ready.')\n                if (webcamCurrent.video.readyState === 4) {\n                    const imgSrc = webcamRef.current?.getScreenshot();\n                    let img = new Image;\n                    img.src = imgSrc;\n                    const date = new Date();\n                    setCapturedTime(date.getFullYear()+'/'+(date.getMonth()+1)+'/'+date.getDate()+' '+date.getHours()+':'+date.getMinutes()+':'+date.getSeconds());\n                    img.onload = () => {\n                        console.log('end screenshot.');\n                        setScreenshot(img);\n                        console.log('screenshot width: '+img.naturalWidth);\n                        console.log('screenshot height: '+img.naturalHeight);\n                        setShutter(false);\n                        setCaptured(true);\n                    }\n                }\n            }\n        }, 2000);\n    }\n    const Detect = async () => {\n        setPredictions(null);\n        if (isCaptured) {\n            console.log('detect start.');\n            setProcessing(true);\n            /*\n            const preds = await model.segmentMultiPerson(screenshot, {\n                flipHorizontal: false,\n                internalResolution: 'medium',\n                segmentationThreshold: 0.7\n            });\n            */\n            const internalResolution = 'full';\n            //const preds = await model.segmentMultiPersonParts(screenshot, {\n            const preds = await model.segmentMultiPerson(screenshot, {\n                internalResolution: internalResolution\n            });\n            console.log('detect end.');\n            if (preds.length) {\n                console.log(preds);\n                setPredictions(preds);\n            } else {\n                console.log('no detection.');\n            }\n            setProcessing(false);\n            setDetected(true);\n        }\n    }\n    const DrawCanvas = async () => {\n        if (isCaptured) {\n            if (canvasRef.current) {\n                console.log('canvas ready.');\n                console.log(canvasRef.current.width);\n                console.log(screenshot.naturalWidth);\n                canvasRef.current.width = screenshot.naturalWidth;\n                canvasRef.current.height = screenshot.naturalHeight;\n\n                const opacity = 0.7;\n                const flipHorizontal = false;\n                const maskBlurAmount = 0;\n                const canvas = canvasRef.current;\n                //const mask = bodyPix.toMask(predictions)\n                if (predictions) {\n                    const foregroundColor = {r: 255, g: 0, b: 0, a: 255};\n                    const backgroundColor = {r: 0, g: 0, b: 0, a: 0};\n                    const mask = bodyPix.toMask(\n                        predictions,\n                        foregroundColor,\n                        backgroundColor\n                    );\n                    // const mask = bodyPix.toColoredPartMask(predictions);\n                    if (isBackgroundEnable) {\n                        bodyPix.drawMask(\n                            canvas,\n                            screenshot,\n                            mask,\n                            opacity,\n                            maskBlurAmount,\n                            flipHorizontal\n                        );\n                    } else {\n                        bodyPix.drawMask(\n                            canvas,\n                            background,\n                            mask,\n                            opacity,\n                            maskBlurAmount,\n                            flipHorizontal\n                        );\n                    }\n                } else {\n                    const context = canvasRef.current.getContext('2d');\n                    if (context) {\n                        if (isBackgroundEnable) {\n                            context.drawImage(screenshot, 0, 0);\n                        } else {\n                            context.drawImage(background, 0, 0);\n                        }\n                    }\n                }\n\n\n                console.log('drawn.');\n            }\n        }\n    }\n    const LoadModel = async () => {\n        console.log('start model loading.');\n        setProcessing(true);\n        /*\n        const architecture = 'ResNet50';\n        const outputStride = 16;\n        const quantBytes = 4;\n        */\n        const architecture = 'MobileNetV1';\n        const outputStride = 16;\n        const quantBytes = 2;\n        const bodypix = await bodyPix.load({\n           architecture: architecture,\n           outputStride: outputStride,\n           quantBytes: quantBytes\n        });\n        setModel(bodypix);\n        setProcessing(false);\n        console.log('model loaded.')\n    }\n\n    useEffect(() => {\n        if (!processing) {\n            if (Object.keys(cameraSize).length === 0) {\n                GetCameraSize();\n            }\n        }\n    }, [processing]);\n\n    useEffect(() => {\n        LoadModel();\n    }, []);\n\n    useEffect(() => {\n        if (screenshotRef.current) {\n            screenshotRef.current = false;\n            return;\n        }\n        GetScreenshot();\n    }, [shutter]);\n\n    useEffect(() => {\n        if (drawCanvasRef.current) {\n            drawCanvasRef.current = false;\n            return;\n        }\n        Detect();\n    }, [isCaptured])\n\n    useEffect(() => {\n        if (detectRef.current) {\n            detectRef.current = false;\n            return;\n        }\n        DrawCanvas();\n    }, [isDetected, isBackgroundEnable])\n\n    console.log('shutter', shutter, 'processing', processing, 'isCaptured', isCaptured, 'condition', (isCaptured && !processing));\n    return (\n        <div \n            style={{\n                width: width, \n                height: height*0.8,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n            }}\n        >\n            {(!shutter && !isCaptured && !processing && Object.keys(cameraSize).length === 0) &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        visibility: 'hidden'\n                    }}\n                />\n            }\n            {(!shutter && !isCaptured && !processing && Object.keys(cameraSize).length === 2) &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        width: '100%',\n                        height: '100%'\n                    }}\n                />\n            }\n            {(shutter && !isCaptured && !processing && Object.keys(cameraSize).length === 2) &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        width: cameraSize[0],\n                        height: cameraSize[1],\n                        visibility: 'hidden',\n                    }}\n                />\n            }\n            {processing && \n                <CircularProgress \n                />\n            }\n            {(isCaptured && !processing) && \n                <>\n                    <canvas\n                        ref={canvasRef}\n                        style={{\n                            margin: 'auto',\n                            width: '100%',\n                            height: '100%',\n                            zIndex: 30\n                        }}\n                    />\n                </>\n            }\n        </div>\n    );\n}\n\ninterface SegmentationProps {\n    background: HTMLImageElement\n    cameraSize: number[]\n    setCameraSize: Function\n}\n\nexport const Segmentation: React.FC<SegmentationProps> = ({\n    background,\n    cameraSize,\n    setCameraSize\n}) => {\n    const [isCameraEnable, setCameraEnable] = useState<boolean>(true);\n    const [isCaptured, setCaptured] = useState<boolean>(false);\n    const [shutter, setShutter] = useState<boolean>(false);\n    const [isDetected, setDetected] = useState<boolean>(false);\n    const [isBackgroundEnable, setBackgroudEnable] = useState<boolean>(true);\n    const [facingMode, setFacingMode] = useState<string>('user');\n    const [processing, setProcessing] = useState<boolean>(false);\n    const [capturedTime, setCapturedTime] = useState<string>('');\n    const [peopleCount, setPeopleCount] = useState<number>(0);\n    const { width, height } = UseWindowDimensions();\n    const webcamRef = useRef<Webcam>(null);\n    return (\n        <Template title='segmentation'>\n            <Buttons\n                isCameraEnable={isCameraEnable}\n                setCameraEnable={setCameraEnable}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                facingMode={facingMode}\n                setFacingMode={setFacingMode}\n                isBackgroundEnable={isBackgroundEnable}\n                setBackgroundEnable={setBackgroudEnable}\n                processing={processing}\n            />\n            <Canvas\n                webcamRef={webcamRef}\n                facingMode={facingMode}\n                width={width}\n                height={height}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                isBackgroundEnable={isBackgroundEnable}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                processing={processing}\n                setProcessing={setProcessing}\n                capturedTime={capturedTime}\n                setCapturedTime={setCapturedTime}\n                peopleCount={peopleCount}\n                setPeopleCount={setPeopleCount}\n                background={background}\n                cameraSize={cameraSize}\n                setCameraSize={setCameraSize}\n            />\n        </Template>\n    );\n}","import React, { useState, useEffect, useRef } from 'react';\nimport { IconButton } from '@material-ui/core';\nimport CameraAltIcon from '@material-ui/icons/CameraAlt';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nimport { Template } from './templates/Template';\nimport Webcam from 'react-webcam';\nimport { Flip } from '@material-ui/icons';\nimport { setBackend } from '@tensorflow/tfjs-core';\n\nconst UseWindowDimensions = () => {\n    const getWindowDimensions = () => {\n        const { innerWidth: width, innerHeight: height } = window;\n        return { width, height }\n    }\n    const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n    useEffect(() => {\n        const onResize = () => {\n            setWindowDimensions(getWindowDimensions());\n        }\n        window.addEventListener('resize', onResize);\n        return () => window.removeEventListener('resize', onResize);\n    }, []);\n    return windowDimensions;\n}\n\ninterface ButtonsProps {\n    \n    isCaptured: boolean\n    setCaptured: Function\n    facingMode: string\n    setFacingMode: Function\n    shutter: boolean\n    setShutter: Function\n}\n\nconst Buttons: React.FC<ButtonsProps> = ({\n    isCaptured,\n    setCaptured,\n    facingMode,\n    setFacingMode,\n    shutter,\n    setShutter,\n}) => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'space-around',\n                alignItems: 'center'\n            }}\n        >\n            <IconButton>\n                <CameraAltIcon \n                    color='primary' \n                    onClick={() => {\n                        if (!isCaptured) {\n                            setShutter(true);\n                        } else {\n                            setCaptured(false);\n                        }\n                    }}\n                />\n            </IconButton>\n            <IconButton disabled={isCaptured}>\n                <FlipCameraIosIcon\n                    color={isCaptured ? 'disabled' : 'primary'}\n                    onClick={() => {\n                        if (facingMode === 'user') {\n                            setFacingMode('environment');\n                        } else if (facingMode === 'environment') {\n                            setFacingMode('user');\n                        }\n                    }}\n                />\n            </IconButton>\n        </div>\n    );\n}\n\ninterface CanvasProps {\n    webcamRef: any\n    isCaptured: boolean\n    setCaptured: Function\n    facingMode: string\n    shutter: boolean\n    setShutter: Function\n    background: HTMLImageElement\n    setBackground: Function\n    width: number\n    height: number\n}\n\nconst Canvas: React.FC<CanvasProps> = ({\n    webcamRef,\n    isCaptured,\n    setCaptured,\n    facingMode,\n    shutter,\n    setShutter,\n    background,\n    setBackground,\n    width,\n    height\n}) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const GetScreenshot = async () => {\n        if (webcamRef.current) {\n            const webcamCurrent = webcamRef.current as any;\n            console.log('webcam ready.')\n            if (webcamCurrent.video.readyState === 4) {\n                const imgSrc = webcamRef.current?.getScreenshot();\n                let img = new Image;\n                img.src = imgSrc;\n                img.onload = () => {\n                    setBackground(img);\n                    setShutter(false);\n                    setCaptured(true);\n                }\n            }\n        }\n    }\n    const DrawCanvas = async () => {\n        if (isCaptured) {\n            if (canvasRef.current) {\n                canvasRef.current.width = background.naturalWidth;\n                canvasRef.current.height = background.naturalHeight;\n                const context = canvasRef.current.getContext('2d');\n                context?.drawImage(background, 0, 0);\n            }\n        }\n    }\n\n    useEffect(() => {\n        GetScreenshot();\n    }, [shutter]);\n\n    useEffect(() => {\n        DrawCanvas();\n    }, [isCaptured]);\n\n    return (\n        <div\n            style={{\n                width: width,\n                height: height*0.8,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n            }}\n        >\n            {!isCaptured &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        width: '100%',\n                        height: '100%'\n                    }}\n                />\n            }\n            {isCaptured &&\n                <>\n                    <canvas\n                        ref={canvasRef}\n                        style={{\n                            margin: 'auto',\n                            width: '100%',\n                            height: '100%',\n                            zIndex: 30\n                        }}\n                    />\n                </>\n            }\n        </div>\n    );\n}\n\ninterface SettingsProps {\n    background: HTMLImageElement\n    setBackground: Function\n    cameraSize: number[]\n}\n\nexport const Settings: React.FC<SettingsProps> = ({\n    background,\n    setBackground,\n    cameraSize\n}) => {\n    const { width, height } = UseWindowDimensions();\n    const [isCaptured, setCaptured] = useState<boolean>(false);\n    const [facingMode, setFacingMode] = useState<string>('user');\n    const [shutter, setShutter] = useState<boolean>(false);\n    const webcamRef = useRef<Webcam>(null);\n    return (\n        <Template title='settings'>\n            <Buttons \n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                facingMode={facingMode}\n                setFacingMode={setFacingMode}\n                shutter={shutter}\n                setShutter={setShutter}\n            />\n            <Canvas\n                webcamRef={webcamRef}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                facingMode={facingMode}\n                shutter={shutter}\n                setShutter={setShutter}\n                background={background}\n                setBackground={setBackground}\n                width={width}\n                height={height}\n            />\n        </Template>\n    )\n}","import React, { useState } from 'react';\n// import { Detector } from './components/Detector';\n// import { Camera } from './components/Webcam';\nimport {\n  BrowserRouter,\n  Switch,\n  Route,\n  Link,\n  Redirect\n} from 'react-router-dom';\nimport { ObjectDetector } from './components/OD';\nimport { Segmentation } from './components/Segmentation';\nimport { Canvas } from './components/Canvas';\nimport { Settings } from './components/Settings';\n\n\nconst App: React.FC = () => {\n  const [background, setBackground] = useState<HTMLImageElement>(new Image);\n  const [cameraSize, setCameraSize] = useState<number[]>([]);\n  return (\n    <BrowserRouter> \n      <Switch>\n        {/*\n        <Route path='/objectdetector'>\n          <ObjectDetector />\n        </Route>\n        <Route path='/canvas'>\n          <Canvas />\n        </Route>\n        */}\n        <Route path='/tfjs/segmentation'>\n          <Segmentation\n            background={background}\n            cameraSize={cameraSize}\n            setCameraSize={setCameraSize}\n          />\n        </Route>\n        <Route path='/tfjs/settings'>\n          <Settings \n            background={background}\n            setBackground={setBackground}\n            cameraSize={cameraSize}\n          />\n        </Route>\n      </Switch>\n      {/*<Link to='/segmentation'>segmentation</Link>*/}\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter as Router } from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router basename={process.env.PUBLIC_URL}>\n      <App />\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}