{"version":3,"sources":["components/OD.tsx","components/Segmentation.tsx","images/people_0.jpeg","components/Canvas.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Buttons","isCameraEnable","setCameraEnable","isCaptured","setCaptured","setShutter","shutter","setDetected","isDetected","facingMode","setFacingMode","isBackgroundEnable","setBackgroundEnable","processing","style","display","justifyContent","alignItems","IconButton","disabled","color","onClick","Switch","defaultChecked","onChange","Canvas","webcamRef","width","height","setProcessing","capturedTime","setCapturedTime","screenshotRef","peopleCount","setPeopleCount","useRef","drawCanvasRef","detectRef","useState","model","setModel","predictions","setPredictions","Image","screenshot","setScreenshot","canvasRef","GetScreenshot","a","console","log","current","webcamCurrent","video","readyState","imgSrc","getScreenshot","img","src","date","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","onload","Detect","detect","preds","length","DrawCanvas","naturalWidth","naturalHeight","context","getContext","drawImage","count","forEach","prediction","class","score","bbox","strokeRect","fillText","LoadModel","cocoSsd","cocossd","useEffect","audio","ref","videoConstraints","margin","textAlign","zIndex","CircularProgress","ObjectDetector","setBackgroudEnable","getWindowDimensions","window","innerWidth","innerHeight","windowDimensions","setWindowDimensions","onResize","addEventListener","removeEventListener","UseWindowDimensions","segmentMultiPersonParts","canvas","mask","bodyPix","architecture","outputStride","multiplier","quantBytes","bodypix","Segmentation","photo","ctx","fillStyle","rectangle_1","Path2D","rect","fill","strokeStyle","rectangle","stroke","rectangle_2","onerror","Draw","border","App","basename","process","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e0cb4be3.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport Switch from '@material-ui/core/Switch';\nimport { IconButton } from '@material-ui/core';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nimport CameraAltIcon from '@material-ui/icons/CameraAlt';\nimport CloudUploadIcon from '@material-ui/icons/CloudUpload';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport Webcam from 'react-webcam';\nimport '@tensorflow/tfjs-backend-cpu';\nimport * as cocoSsd from '@tensorflow-models/coco-ssd';\n\nconst UseWindowDimensions = () => {\n    const getWindowDimensions = () => {\n        const { innerWidth: width, innerHeight: height } = window;\n        return { width, height }\n    }\n    const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n    useEffect(() => {\n        const onResize = () => {\n            setWindowDimensions(getWindowDimensions());\n        }\n        window.addEventListener('resize', onResize);\n        return () => window.removeEventListener('resize', onResize);\n    }, []);\n    return windowDimensions;\n}\n\ninterface ButtonsProps {\n    isCameraEnable: boolean\n    setCameraEnable: Function\n    isCaptured: boolean\n    setCaptured: Function\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    facingMode: string\n    setFacingMode: Function\n    isBackgroundEnable: boolean\n    setBackgroundEnable: Function\n    processing: boolean\n}\nconst Buttons: React.FC<ButtonsProps> = ({\n    isCameraEnable,\n    setCameraEnable,\n    isCaptured,\n    setCaptured,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    facingMode,\n    setFacingMode,\n    isBackgroundEnable,\n    setBackgroundEnable,\n    processing\n}) => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'space-around',\n                alignItems: 'center'\n            }}\n        >\n            {/* camera start or capture button */}\n            <IconButton disabled={processing}>\n                {isCaptured ||\n                    <CameraAltIcon color={processing ? 'disabled' : 'primary'} onClick={() => setShutter(true)}/>\n                }\n                {isCaptured &&\n                    <CameraAltIcon \n                        color={processing ? 'disabled' : 'primary'} \n                        onClick={() => {\n                            setCaptured(false)\n                            setDetected(false)\n                        }}\n                    />\n                }\n            </IconButton>\n\n            {/* select camera */}\n            <IconButton disabled={isCaptured || processing}>\n                {(isCaptured) && \n                    <FlipCameraIosIcon color='disabled'/>\n                }\n                {isCaptured ||\n                    <>\n                        {facingMode === 'user' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('environment')}/>\n                        }\n                        {facingMode === 'environment' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('user')}/>\n                        }\n                    </>\n                }\n            </IconButton>\n\n            {/* background */}\n            <Switch defaultChecked color='primary' disabled={!isCaptured} onChange={() => setBackgroundEnable(!isBackgroundEnable)} />\n\n            {/* upload */}\n            <IconButton disabled={true}>\n                <CloudUploadIcon color='disabled'/>\n            </IconButton>\n        </div>\n    );\n}\n\ninterface CanvasProps {\n    webcamRef: any\n    facingMode: string\n    width: number\n    height: number\n    isCaptured: boolean\n    setCaptured: Function\n    isBackgroundEnable: boolean\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    processing: boolean\n    setProcessing: Function\n    capturedTime: string\n    setCapturedTime: Function\n    peopleCount: number\n    setPeopleCount: Function\n}\n\nconst Canvas: React.FC<CanvasProps> = ({\n    webcamRef,\n    facingMode,\n    width,\n    height,\n    isCaptured,\n    setCaptured,\n    isBackgroundEnable,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    processing,\n    setProcessing,\n    capturedTime,\n    setCapturedTime,\n    peopleCount,\n    setPeopleCount\n}) => {\n    const screenshotRef = useRef(true);\n    const drawCanvasRef = useRef(true);\n    const detectRef = useRef(true);\n    const [model, setModel] = useState<any>(null);\n    const [predictions, setPredictions] = useState<any>(null);\n    const [screenshot, setScreenshot] = useState<HTMLImageElement>(new Image);\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const GetScreenshot = async () => {\n        console.log('start screenshot.');\n        if (webcamRef.current) {\n            const webcamCurrent = webcamRef.current as any;\n            console.log('webcam ready.')\n            if (webcamCurrent.video.readyState === 4) {\n                const imgSrc = webcamRef.current?.getScreenshot();\n                let img = new Image;\n                img.src = imgSrc;\n                const date = new Date();\n                setCapturedTime(date.getFullYear()+'/'+(date.getMonth()+1)+'/'+date.getDate()+' '+date.getHours()+':'+date.getMinutes()+':'+date.getSeconds());\n                img.onload = () => {\n                    console.log('end screenshot.');\n                    setScreenshot(img);\n                    setShutter(false);\n                    setCaptured(true);\n                }\n            }\n        }\n    }\n    const Detect = async () => {\n        setPredictions(null);\n        if (isCaptured) {\n            console.log('detect start.');\n            setProcessing(true);\n            const preds = await model.detect(screenshot);\n            console.log('detect end.');\n            if (preds.length) {\n                console.log(predictions);\n                setPredictions(preds);\n            }\n            setProcessing(false);\n            setDetected(true);\n        }\n    }\n    const DrawCanvas = async () => {\n        if (isCaptured) {\n            if (canvasRef.current) {\n                console.log('canvas ready.');\n                console.log(canvasRef.current.width);\n                console.log(screenshot.naturalWidth);\n                canvasRef.current.width = screenshot.naturalWidth;\n                canvasRef.current.height = screenshot.naturalHeight;\n                const context = canvasRef.current.getContext('2d');\n                if (isBackgroundEnable) {\n                    context?.drawImage(screenshot, 0, 0);\n                }\n                let count: number = 0;\n                if (predictions) {\n                    predictions.forEach((prediction: any) => {\n                        if (prediction.class === 'person' && prediction.score >= 0.5) {\n                            count++;\n                            const bbox = prediction.bbox;\n                            context?.strokeRect(bbox[0], bbox[1], bbox[2], bbox[3]);\n                        }\n                    })\n                }\n\n                const date = new Date();\n                context?.fillText(\n                    capturedTime+' count: '+count, 0, 10\n                );\n\n                console.log('drawn.');\n            }\n        }\n    }\n    const LoadModel = async () => {\n        console.log('start model loading.');\n        setProcessing(true);\n        const cocossd = await cocoSsd.load();\n        setModel(cocossd);\n        setProcessing(false);\n        console.log('model loaded.')\n    }\n    useEffect(() => {\n        LoadModel();\n    }, []);\n\n    useEffect(() => {\n        if (screenshotRef.current) {\n            screenshotRef.current = false;\n            return;\n        }\n        GetScreenshot();\n    }, [shutter]);\n\n    useEffect(() => {\n        if (drawCanvasRef.current) {\n            drawCanvasRef.current = false;\n            return;\n        }\n        Detect();\n    }, [isCaptured])\n\n    useEffect(() => {\n        if (detectRef.current) {\n            detectRef.current = false;\n            return;\n        }\n        DrawCanvas();\n    }, [isDetected, isBackgroundEnable])\n\n    console.log('shutter', shutter, 'processing', processing, 'isCaptured', isCaptured, 'condition', (isCaptured && !processing));\n    return (\n        <div \n            style={{\n                width: width, \n                height: height*0.9,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n            }}\n        >\n            {(!isCaptured && !processing) &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        width: '100%',\n                        height: '100%'\n                    }}\n                />\n            }\n            {processing && \n                <CircularProgress \n                />\n            }\n            {(isCaptured && !processing) && \n                <>\n                    <canvas\n                        ref={canvasRef}\n                        style={{\n                            margin: 'auto',\n                            width: '100%',\n                            height: '100%',\n                            zIndex: 30\n                        }}\n                    />\n                </>\n            }\n        </div>\n    );\n}\n\nexport const ObjectDetector: React.FC = () => {\n    const [isCameraEnable, setCameraEnable] = useState<boolean>(true);\n    const [isCaptured, setCaptured] = useState<boolean>(false);\n    const [shutter, setShutter] = useState<boolean>(false);\n    const [isDetected, setDetected] = useState<boolean>(false);\n    const [isBackgroundEnable, setBackgroudEnable] = useState<boolean>(true);\n    const [facingMode, setFacingMode] = useState<string>('user');\n    const [processing, setProcessing] = useState<boolean>(false);\n    const [capturedTime, setCapturedTime] = useState<string>('');\n    const [peopleCount, setPeopleCount] = useState<number>(0);\n    const { width, height } = UseWindowDimensions();\n    const webcamRef = useRef<Webcam>(null);\n    return (\n        <div>\n            <Buttons\n                isCameraEnable={isCameraEnable}\n                setCameraEnable={setCameraEnable}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                facingMode={facingMode}\n                setFacingMode={setFacingMode}\n                isBackgroundEnable={isBackgroundEnable}\n                setBackgroundEnable={setBackgroudEnable}\n                processing={processing}\n            />\n            <Canvas\n                webcamRef={webcamRef}\n                facingMode={facingMode}\n                width={width}\n                height={height}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                isBackgroundEnable={isBackgroundEnable}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                processing={processing}\n                setProcessing={setProcessing}\n                capturedTime={capturedTime}\n                setCapturedTime={setCapturedTime}\n                peopleCount={peopleCount}\n                setPeopleCount={setPeopleCount}\n            />\n        </div>\n    );\n}","import React, { useState, useEffect, useRef } from 'react';\nimport Switch from '@material-ui/core/Switch';\nimport { IconButton } from '@material-ui/core';\nimport FlipCameraIosIcon from '@material-ui/icons/FlipCameraIos';\nimport CameraAltIcon from '@material-ui/icons/CameraAlt';\nimport CloudUploadIcon from '@material-ui/icons/CloudUpload';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport Webcam from 'react-webcam';\nimport '@tensorflow/tfjs-backend-cpu';\nimport * as bodyPix from '@tensorflow-models/body-pix';\n\nconst UseWindowDimensions = () => {\n    const getWindowDimensions = () => {\n        const { innerWidth: width, innerHeight: height } = window;\n        return { width, height }\n    }\n    const [windowDimensions, setWindowDimensions] = useState(getWindowDimensions());\n    useEffect(() => {\n        const onResize = () => {\n            setWindowDimensions(getWindowDimensions());\n        }\n        window.addEventListener('resize', onResize);\n        return () => window.removeEventListener('resize', onResize);\n    }, []);\n    return windowDimensions;\n}\n\ninterface ButtonsProps {\n    isCameraEnable: boolean\n    setCameraEnable: Function\n    isCaptured: boolean\n    setCaptured: Function\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    facingMode: string\n    setFacingMode: Function\n    isBackgroundEnable: boolean\n    setBackgroundEnable: Function\n    processing: boolean\n}\nconst Buttons: React.FC<ButtonsProps> = ({\n    isCameraEnable,\n    setCameraEnable,\n    isCaptured,\n    setCaptured,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    facingMode,\n    setFacingMode,\n    isBackgroundEnable,\n    setBackgroundEnable,\n    processing\n}) => {\n    return (\n        <div\n            style={{\n                display: 'flex',\n                justifyContent: 'space-around',\n                alignItems: 'center'\n            }}\n        >\n            {/* camera start or capture button */}\n            <IconButton disabled={processing}>\n                {isCaptured ||\n                    <CameraAltIcon color={processing ? 'disabled' : 'primary'} onClick={() => setShutter(true)}/>\n                }\n                {isCaptured &&\n                    <CameraAltIcon \n                        color={processing ? 'disabled' : 'primary'} \n                        onClick={() => {\n                            setCaptured(false)\n                            setDetected(false)\n                        }}\n                    />\n                }\n            </IconButton>\n\n            {/* select camera */}\n            <IconButton disabled={isCaptured || processing}>\n                {(isCaptured) && \n                    <FlipCameraIosIcon color='disabled'/>\n                }\n                {isCaptured ||\n                    <>\n                        {facingMode === 'user' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('environment')}/>\n                        }\n                        {facingMode === 'environment' &&\n                            <FlipCameraIosIcon color={processing ? 'disabled' : 'primary'} onClick={() => setFacingMode('user')}/>\n                        }\n                    </>\n                }\n            </IconButton>\n\n            {/* background */}\n            <Switch defaultChecked color='primary' disabled={!isCaptured} onChange={() => setBackgroundEnable(!isBackgroundEnable)} />\n\n            {/* upload */}\n            <IconButton disabled={true}>\n                <CloudUploadIcon color='disabled'/>\n            </IconButton>\n        </div>\n    );\n}\n\ninterface CanvasProps {\n    webcamRef: any\n    facingMode: string\n    width: number\n    height: number\n    isCaptured: boolean\n    setCaptured: Function\n    isBackgroundEnable: boolean\n    shutter: boolean\n    setShutter: Function\n    isDetected: boolean\n    setDetected: Function\n    processing: boolean\n    setProcessing: Function\n    capturedTime: string\n    setCapturedTime: Function\n    peopleCount: number\n    setPeopleCount: Function\n}\n\nconst Canvas: React.FC<CanvasProps> = ({\n    webcamRef,\n    facingMode,\n    width,\n    height,\n    isCaptured,\n    setCaptured,\n    isBackgroundEnable,\n    shutter,\n    setShutter,\n    isDetected,\n    setDetected,\n    processing,\n    setProcessing,\n    capturedTime,\n    setCapturedTime,\n    peopleCount,\n    setPeopleCount\n}) => {\n    const screenshotRef = useRef(true);\n    const drawCanvasRef = useRef(true);\n    const detectRef = useRef(true);\n    const [model, setModel] = useState<any>(null);\n    const [predictions, setPredictions] = useState<any>(null);\n    const [screenshot, setScreenshot] = useState<HTMLImageElement>(new Image);\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    const GetScreenshot = async () => {\n        console.log('start screenshot.');\n        if (webcamRef.current) {\n            const webcamCurrent = webcamRef.current as any;\n            console.log('webcam ready.')\n            if (webcamCurrent.video.readyState === 4) {\n                const imgSrc = webcamRef.current?.getScreenshot();\n                let img = new Image;\n                img.src = imgSrc;\n                const date = new Date();\n                setCapturedTime(date.getFullYear()+'/'+(date.getMonth()+1)+'/'+date.getDate()+' '+date.getHours()+':'+date.getMinutes()+':'+date.getSeconds());\n                img.onload = () => {\n                    console.log('end screenshot.');\n                    setScreenshot(img);\n                    setShutter(false);\n                    setCaptured(true);\n                }\n            }\n        }\n    }\n    const Detect = async () => {\n        setPredictions(null);\n        if (isCaptured) {\n            console.log('detect start.');\n            setProcessing(true);\n            /*\n            const preds = await model.segmentMultiPerson(screenshot, {\n                flipHorizontal: false,\n                internalResolution: 'medium',\n                segmentationThreshold: 0.7\n            });\n            */\n           const preds = await model.segmentMultiPersonParts(screenshot);\n            console.log('detect end.');\n            if (preds.length) {\n                console.log(preds);\n                setPredictions(preds);\n            } else {\n                console.log('no detection.');\n            }\n            setProcessing(false);\n            setDetected(true);\n        }\n    }\n    const DrawCanvas = async () => {\n        if (isCaptured) {\n            if (canvasRef.current) {\n                console.log('canvas ready.');\n                console.log(canvasRef.current.width);\n                console.log(screenshot.naturalWidth);\n                canvasRef.current.width = screenshot.naturalWidth;\n                canvasRef.current.height = screenshot.naturalHeight;\n                /*\n                const context = canvasRef.current.getContext('2d');\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = screenshot.naturalWidth;\n                tempCanvas.height = screenshot.naturalHeight;\n                const tempContext = tempCanvas.getContext('2d');\n                if (isBackgroundEnable) {\n                    context?.drawImage(screenshot, 0, 0);\n                }\n                context?.save();\n                let count: number = 0;\n                if (predictions) {\n                    predictions.forEach((prediction: any) => {\n                        count++;\n                        const frontColor = {r: 255, g: 0, b: 0, a: 128};\n                        const backColor = {r: 0, g: 0, b: 0, a: 0};\n                        const mask: any = bodyPix.toMask(prediction, frontColor, backColor);\n                        tempContext?.putImageData(mask, 0, 0);\n                    })\n                }\n                if (context) {\n                    context.globalCompositeOperation = 'destination-out';\n                    context.drawImage(tempCanvas, 0, 0, canvasRef.current.width, canvasRef.current.height);\n                    context.restore();\n\n                    const date = new Date();\n                    context.fillStyle = 'rgb(255, 0, 0)';\n                    context.fillText(\n                        capturedTime+' count: '+count, 0, 10\n                    );\n                }\n                */\n               const opacity = 0.7;\n               const flipHorizontal = false;\n               const maskBlurAmount = 0;\n               const canvas = canvasRef.current;\n               //const mask = bodyPix.toMask(predictions)\n               const mask = bodyPix.toColoredPartMask(predictions);\n               bodyPix.drawMask(\n                   canvas,\n                   screenshot,\n                   mask,\n                   opacity,\n                   maskBlurAmount,\n                   flipHorizontal\n               );\n\n\n                console.log('drawn.');\n            }\n        }\n    }\n    const LoadModel = async () => {\n        console.log('start model loading.');\n        setProcessing(true);\n        const bodypix = await bodyPix.load({\n            architecture: 'MobileNetV1',\n            outputStride: 16,\n            multiplier: 0.75,\n            quantBytes: 2\n        });\n        setModel(bodypix);\n        setProcessing(false);\n        console.log('model loaded.')\n    }\n    useEffect(() => {\n        LoadModel();\n    }, []);\n\n    useEffect(() => {\n        if (screenshotRef.current) {\n            screenshotRef.current = false;\n            return;\n        }\n        GetScreenshot();\n    }, [shutter]);\n\n    useEffect(() => {\n        if (drawCanvasRef.current) {\n            drawCanvasRef.current = false;\n            return;\n        }\n        Detect();\n    }, [isCaptured])\n\n    useEffect(() => {\n        if (detectRef.current) {\n            detectRef.current = false;\n            return;\n        }\n        DrawCanvas();\n    }, [isDetected, isBackgroundEnable])\n\n    console.log('shutter', shutter, 'processing', processing, 'isCaptured', isCaptured, 'condition', (isCaptured && !processing));\n    return (\n        <div \n            style={{\n                width: width, \n                height: height*0.9,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n            }}\n        >\n            {(!isCaptured && !processing) &&\n                <Webcam\n                    audio={false}\n                    ref={webcamRef}\n                    videoConstraints={{\n                        facingMode: facingMode\n                    }}\n                    style={{\n                        margin: 'auto',\n                        textAlign: 'center',\n                        zIndex: 9,\n                        width: '100%',\n                        height: '100%'\n                    }}\n                />\n            }\n            {processing && \n                <CircularProgress \n                />\n            }\n            {(isCaptured && !processing) && \n                <>\n                    <canvas\n                        ref={canvasRef}\n                        style={{\n                            margin: 'auto',\n                            width: '100%',\n                            height: '100%',\n                            zIndex: 30\n                        }}\n                    />\n                </>\n            }\n        </div>\n    );\n}\n\nexport const Segmentation: React.FC = () => {\n    const [isCameraEnable, setCameraEnable] = useState<boolean>(true);\n    const [isCaptured, setCaptured] = useState<boolean>(false);\n    const [shutter, setShutter] = useState<boolean>(false);\n    const [isDetected, setDetected] = useState<boolean>(false);\n    const [isBackgroundEnable, setBackgroudEnable] = useState<boolean>(true);\n    const [facingMode, setFacingMode] = useState<string>('user');\n    const [processing, setProcessing] = useState<boolean>(false);\n    const [capturedTime, setCapturedTime] = useState<string>('');\n    const [peopleCount, setPeopleCount] = useState<number>(0);\n    const { width, height } = UseWindowDimensions();\n    const webcamRef = useRef<Webcam>(null);\n    return (\n        <div>\n            <Buttons\n                isCameraEnable={isCameraEnable}\n                setCameraEnable={setCameraEnable}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                facingMode={facingMode}\n                setFacingMode={setFacingMode}\n                isBackgroundEnable={isBackgroundEnable}\n                setBackgroundEnable={setBackgroudEnable}\n                processing={processing}\n            />\n            <Canvas\n                webcamRef={webcamRef}\n                facingMode={facingMode}\n                width={width}\n                height={height}\n                isCaptured={isCaptured}\n                setCaptured={setCaptured}\n                isBackgroundEnable={isBackgroundEnable}\n                shutter={shutter}\n                setShutter={setShutter}\n                isDetected={isDetected}\n                setDetected={setDetected}\n                processing={processing}\n                setProcessing={setProcessing}\n                capturedTime={capturedTime}\n                setCapturedTime={setCapturedTime}\n                peopleCount={peopleCount}\n                setPeopleCount={setPeopleCount}\n            />\n        </div>\n    );\n}","export default __webpack_public_path__ + \"static/media/people_0.03d88435.jpeg\";","import { image } from '@tensorflow/tfjs-core';\nimport React, { useRef, useState, useEffect } from 'react';\nimport photo from '../images/people_0.jpeg';\n\nexport const Canvas: React.FC = () => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    //const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);\n    const Draw = () => {\n        console.log('draw start.');\n        let img = new Image();\n        img.src = photo;\n        console.log(img);\n        img.onload = () => {\n            console.log('img onload.');\n            if (canvasRef.current) {\n                const ctx = canvasRef.current.getContext('2d');\n                if (ctx) {\n                    ctx.drawImage(img, 0, 0);\n\n                    ctx.fillStyle = 'rgb(0, 0, 0)';\n                    const rectangle_1 = new Path2D();\n                    rectangle_1.rect(35, 25, 50, 50);\n                    ctx.fill(rectangle_1);\n\n                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n                    const rectangle = new Path2D();\n                    rectangle.rect(10, 10, 50, 50);\n                    ctx.stroke(rectangle);\n\n                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n                    const rectangle_2 = new Path2D();\n                    rectangle_2.rect(160, 25, 50, 50);\n                    ctx.fill(rectangle_2);\n\n                }\n            }\n        };\n        img.onerror = () => {\n            console.log('no file.')\n        }\n    }\n    useEffect(() => {\n        Draw();\n    }, []);\n    return (\n        <div>\n            canvas\n            <canvas \n                ref={canvasRef}\n                style={{\n                    width: '150',\n                    height: '150',\n                    border: '1px solid',\n                }}\n            />\n        </div>\n    );\n}","import React from 'react';\n// import { Detector } from './components/Detector';\n// import { Camera } from './components/Webcam';\nimport {\n  BrowserRouter,\n  Switch,\n  Route\n} from 'react-router-dom';\nimport { ObjectDetector } from './components/OD';\nimport { Segmentation } from './components/Segmentation';\nimport { Canvas } from './components/Canvas';\n\n\nconst App: React.FC = () => {\n  return (\n    <BrowserRouter basename={process.env.PUBLIC_URL}>\n      <Switch>\n        <Route path='/objectdetector'>\n          <ObjectDetector />\n        </Route>\n        <Route path='/segmentation'>\n          <Segmentation />\n        </Route>\n        <Route path='/canvas'>\n          <Canvas />\n        </Route>\n      </Switch>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}